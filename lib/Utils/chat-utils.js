Object.defineProperty(exports,"__esModule",{value:!0});exports.processSyncAction=exports.chatModificationToAppPatch=exports.decodePatches=exports.decodeSyncdSnapshot=exports.downloadExternalPatch=exports.downloadExternalBlob=exports.extractSyncdPatches=exports.decodeSyncdPatch=exports.decodeSyncdMutations=exports.encodeSyncdPatch=exports.newLTHashState=void 0;
const boom_1=require("@hapi/boom"),WAProto_1=require("../../WAProto"),LabelAssociation_1=require("../Types/LabelAssociation"),WABinary_1=require("../WABinary"),crypto_1=require("./crypto"),generics_1=require("./generics"),lt_hash_1=require("./lt-hash"),messages_media_1=require("./messages-media"),mutationKeys=a=>{a=(0,crypto_1.hkdf)(a,160,{info:"WhatsApp Mutation Keys"});return{indexKey:a.slice(0,32),valueEncryptionKey:a.slice(32,64),valueMacKey:a.slice(64,96),snapshotMacKey:a.slice(96,128),patchMacKey:a.slice(128,
160)}},generateMac=(a,b,c,g)=>{let f;switch(a){case WAProto_1.proto.SyncdMutation.SyncdOperation.SET:f=1;break;case WAProto_1.proto.SyncdMutation.SyncdOperation.REMOVE:f=2}a=Buffer.from([f]);c=Buffer.concat([a,Buffer.from(c,"base64")]);a=Buffer.alloc(8);a.set([c.length],a.length-1);b=Buffer.concat([c,b,a]);return(0,crypto_1.hmacSign)(b,g,"sha512").slice(0,32)},to64BitNetworkOrder=a=>{const b=Buffer.alloc(8);b.writeUint32BE(a,4);return b},makeLtHashGenerator=({indexValueMap:a,hash:b})=>{a={...a};const c=
[],g=[];return{mix:({indexMac:f,valueMac:h,operation:e})=>{const k=Buffer.from(f).toString("base64"),l=a[k];if(e===WAProto_1.proto.SyncdMutation.SyncdOperation.REMOVE){if(!l)throw new boom_1.Boom("tried remove, but no previous op",{data:{indexMac:f,valueMac:h}});delete a[k]}else c.push((new Uint8Array(h)).buffer),a[k]={valueMac:h};l&&g.push((new Uint8Array(l.valueMac)).buffer)},finish:()=>{var f=(new Uint8Array(b)).buffer;f=lt_hash_1.LT_HASH_ANTI_TAMPERING.subtractThenAdd(f,c,g);return{hash:Buffer.from(f),
indexValueMap:a}}}},generateSnapshotMac=(a,b,c,g)=>{a=Buffer.concat([a,to64BitNetworkOrder(b),Buffer.from(c,"utf-8")]);return(0,crypto_1.hmacSign)(a,g,"sha256")},generatePatchMac=(a,b,c,g,f)=>{a=Buffer.concat([a,...b,to64BitNetworkOrder(c),Buffer.from(g,"utf-8")]);return(0,crypto_1.hmacSign)(a,f)},newLTHashState=()=>({version:0,hash:Buffer.alloc(128),indexValueMap:{}});exports.newLTHashState=newLTHashState;
const encodeSyncdPatch=async({type:a,index:b,syncAction:c,apiVersion:g,operation:f},h,e,k)=>{k=h?await k(h):void 0;if(!k)throw new boom_1.Boom(`myAppStateKey ("${h}") not present`,{statusCode:404});h=Buffer.from(h,"base64");e={...e,indexValueMap:{...e.indexValueMap}};b=Buffer.from(JSON.stringify(b));c=WAProto_1.proto.SyncActionData.fromObject({index:b,value:c,padding:new Uint8Array(0),version:g});g=WAProto_1.proto.SyncActionData.encode(c).finish();c=mutationKeys(k.keyData);g=(0,crypto_1.aesEncrypt)(g,
c.valueEncryptionKey);k=generateMac(f,g,h,c.valueMacKey);b=(0,crypto_1.hmacSign)(b,c.indexKey);var l=makeLtHashGenerator(e);l.mix({indexMac:b,valueMac:k,operation:f});Object.assign(e,l.finish());e.version+=1;l=generateSnapshotMac(e.hash,e.version,a,c.snapshotMacKey);a={patchMac:generatePatchMac(l,[k],e.version,a,c.patchMacKey),snapshotMac:l,keyId:{id:h},mutations:[{operation:f,record:{index:{blob:b},value:{blob:Buffer.concat([g,k])},keyId:{id:h}}}]};f=b.toString("base64");e.indexValueMap[f]={valueMac:k};
return{patch:a,state:e}};exports.encodeSyncdPatch=encodeSyncdPatch;
const decodeSyncdMutations=async(a,b,c,g,f)=>{async function h(p){p=Buffer.from(p).toString("base64");const m=await c(p);if(!m)throw new boom_1.Boom(`failed to find key "${p}" to decode mutation`,{statusCode:404,data:{msgMutations:a}});return mutationKeys(m.keyData)}b=makeLtHashGenerator(b);for(const p of a){const m="operation"in p?p.operation:WAProto_1.proto.SyncdMutation.SyncdOperation.SET,n="record"in p&&p.record?p.record:p;var e=await h(n.keyId.id),k=Buffer.from(n.value.blob),l=k.slice(0,-32);
k=k.slice(-32);if(f){const d=generateMac(m,l,n.keyId.id,e.valueMacKey);if(0!==Buffer.compare(d,k))throw new boom_1.Boom("HMAC content verification failed");}l=(0,crypto_1.aesDecrypt)(l,e.valueEncryptionKey);l=WAProto_1.proto.SyncActionData.decode(l);if(f&&(e=(0,crypto_1.hmacSign)(l.index,e.indexKey),0!==Buffer.compare(e,n.index.blob)))throw new boom_1.Boom("HMAC index verification failed");e=Buffer.from(l.index).toString();g({syncAction:l,index:JSON.parse(e)});b.mix({indexMac:n.index.blob,valueMac:k,
operation:m})}return b.finish()};exports.decodeSyncdMutations=decodeSyncdMutations;
const decodeSyncdPatch=async(a,b,c,g,f,h)=>{if(h){var e=Buffer.from(a.keyId.id).toString("base64"),k=await g(e);if(!k)throw new boom_1.Boom(`failed to find key "${e}" to decode patch`,{statusCode:404,data:{msg:a}});e=mutationKeys(k.keyData);k=a.mutations.map(l=>l.record.value.blob.slice(-32));b=generatePatchMac(a.snapshotMac,k,(0,generics_1.toNumber)(a.version.version),b,e.patchMacKey);if(0!==Buffer.compare(b,a.patchMac))throw new boom_1.Boom("Invalid patch mac");}return await (0,exports.decodeSyncdMutations)(a.mutations,
c,g,f,h)};exports.decodeSyncdPatch=decodeSyncdPatch;
const extractSyncdPatches=async(a,b)=>{a=(0,WABinary_1.getBinaryNodeChild)(a,"sync");a=(0,WABinary_1.getBinaryNodeChildren)(a,"collection");const c={};await Promise.all(a.map(async g=>{var f=(0,WABinary_1.getBinaryNodeChild)(g,"patches"),h=(0,WABinary_1.getBinaryNodeChildren)(f||g,"patch");const e=(0,WABinary_1.getBinaryNodeChild)(g,"snapshot");f=[];const k=g.attrs.name,l="true"===g.attrs.has_more_patches;var p=void 0;e&&e.content&&(Buffer.isBuffer(e)||(e.content=Buffer.from(Object.values(e.content))),
p=WAProto_1.proto.ExternalBlobReference.decode(e.content),p=await (0,exports.downloadExternalBlob)(p,b),p=WAProto_1.proto.SyncdSnapshot.decode(p));for(let {content:m}of h)m&&(Buffer.isBuffer(m)||(m=Buffer.from(Object.values(m))),h=WAProto_1.proto.SyncdPatch.decode(m),h.version||(h.version={version:+g.attrs.version+1}),f.push(h));c[k]={patches:f,hasMorePatches:l,snapshot:p}}));return c};exports.extractSyncdPatches=extractSyncdPatches;
const downloadExternalBlob=async(a,b)=>{a=await (0,messages_media_1.downloadContentFromMessage)(a,"md-app-state",{options:b});b=[];for await(const c of a)b.push(c);return Buffer.concat(b)};exports.downloadExternalBlob=downloadExternalBlob;const downloadExternalPatch=async(a,b)=>{a=await (0,exports.downloadExternalBlob)(a,b);return WAProto_1.proto.SyncdMutations.decode(a)};exports.downloadExternalPatch=downloadExternalPatch;
const decodeSyncdSnapshot=async(a,b,c,g,f=!0)=>{const h=(0,exports.newLTHashState)();h.version=(0,generics_1.toNumber)(b.version.version);const e={},{hash:k,indexValueMap:l}=await (0,exports.decodeSyncdMutations)(b.records,h,c,"undefined"===typeof g||h.version>g?p=>{var m;const n=null===(m=p.syncAction.index)||void 0===m?void 0:m.toString();e[n]=p}:()=>{},f);h.hash=k;h.indexValueMap=l;if(f){g=Buffer.from(b.keyId.id).toString("base64");c=await c(g);if(!c)throw new boom_1.Boom(`failed to find key "${g}" to decode mutation`);
c=mutationKeys(c.keyData);c=generateSnapshotMac(h.hash,h.version,a,c.snapshotMacKey);if(0!==Buffer.compare(b.mac,c))throw new boom_1.Boom(`failed to verify LTHash at ${h.version} of ${a} from snapshot`);}return{state:h,mutationMap:e}};exports.decodeSyncdSnapshot=decodeSyncdSnapshot;
const decodePatches=async(a,b,c,g,f,h,e,k=!0)=>{var l;c={...c,indexValueMap:{...c.indexValueMap}};const p={};for(let n=0;n<b.length;n++){const d=b[n],{version:r,keyId:q,snapshotMac:x}=d;if(d.externalMutations){null===e||void 0===e||e.trace({name:a,version:r},"downloading external patch");var m=await (0,exports.downloadExternalPatch)(d.externalMutations,f);null===e||void 0===e||e.debug({name:a,version:r,mutations:m.mutations.length},"downloaded external patch");null===(l=d.mutations)||void 0===l||
l.push(...m.mutations)}m=(0,generics_1.toNumber)(r.version);c.version=m;m=await (0,exports.decodeSyncdPatch)(d,a,c,g,"undefined"===typeof h||m>h?u=>{var v;const t=null===(v=u.syncAction.index)||void 0===v?void 0:v.toString();p[t]=u}:()=>{},!0);c.hash=m.hash;c.indexValueMap=m.indexValueMap;if(k){m=Buffer.from(q.id).toString("base64");const u=await g(m);if(!u)throw new boom_1.Boom(`failed to find key "${m}" to decode mutation`);m=mutationKeys(u.keyData);m=generateSnapshotMac(c.hash,c.version,a,m.snapshotMacKey);
if(0!==Buffer.compare(x,m))throw new boom_1.Boom(`failed to verify LTHash at ${c.version} of ${a}`);}d.mutations=[]}return{state:c,mutationMap:p}};exports.decodePatches=decodePatches;
const chatModificationToAppPatch=(a,b)=>{const c=WAProto_1.proto.SyncdMutation.SyncdOperation;var g=f=>{if(Array.isArray(f)){const h=f[f.length-1];f={lastMessageTimestamp:null===h||void 0===h?void 0:h.messageTimestamp,messages:(null===f||void 0===f?0:f.length)?f.map(e=>{var k,l;if(!((null===(k=e.key)||void 0===k?0:k.id)&&(null===(l=e.key)||void 0===l?0:l.remoteJid)))throw new boom_1.Boom("Incomplete key",{statusCode:400,data:e});if((0,WABinary_1.isJidGroup)(e.key.remoteJid)&&!e.key.fromMe&&!e.key.participant)throw new boom_1.Boom("Expected not from me message to have participant",
{statusCode:400,data:e});if(!e.messageTimestamp||!(0,generics_1.toNumber)(e.messageTimestamp))throw new boom_1.Boom("Missing timestamp in last message list",{statusCode:400,data:e});e.key.participant&&(e.key.participant=(0,WABinary_1.jidNormalizedUser)(e.key.participant));return e}):void 0}}return f};if("mute"in a)b={syncAction:{muteAction:{muted:!!a.mute,muteEndTimestamp:a.mute||void 0}},index:["mute",b],type:"regular_high",apiVersion:2,operation:c.SET};else if("archive"in a)b={syncAction:{archiveChatAction:{archived:!!a.archive,
messageRange:g(a.lastMessages)}},index:["archive",b],type:"regular_low",apiVersion:3,operation:c.SET};else if("markRead"in a)b={syncAction:{markChatAsReadAction:{read:a.markRead,messageRange:g(a.lastMessages)}},index:["markChatAsRead",b],type:"regular_low",apiVersion:3,operation:c.SET};else if("clear"in a){if("all"===a.clear)throw new boom_1.Boom("not supported");a=a.clear.messages[0];b={syncAction:{deleteMessageForMeAction:{deleteMedia:!1,messageTimestamp:a.timestamp}},index:["deleteMessageForMe",
b,a.id,a.fromMe?"1":"0","0"],type:"regular_high",apiVersion:3,operation:c.SET}}else if("pin"in a)b={syncAction:{pinAction:{pinned:!!a.pin}},index:["pin_v1",b],type:"regular_low",apiVersion:5,operation:c.SET};else if("star"in a)g=a.star.messages[0],b={syncAction:{starAction:{starred:!!a.star.star}},index:["star",b,g.id,g.fromMe?"1":"0","0"],type:"regular_low",apiVersion:2,operation:c.SET};else if("delete"in a)b={syncAction:{deleteChatAction:{messageRange:g(a.lastMessages)}},index:["deleteChat",b,"1"],
type:"regular_high",apiVersion:6,operation:c.SET};else if("pushNameSetting"in a)b={syncAction:{pushNameSetting:{name:a.pushNameSetting}},index:["setting_pushName"],type:"critical_block",apiVersion:1,operation:c.SET};else if("addChatLabel"in a)b={syncAction:{labelAssociationAction:{labeled:!0}},index:[LabelAssociation_1.LabelAssociationType.Chat,a.addChatLabel.labelId,b],type:"regular",apiVersion:3,operation:c.SET};else if("removeChatLabel"in a)b={syncAction:{labelAssociationAction:{labeled:!1}},index:[LabelAssociation_1.LabelAssociationType.Chat,
a.removeChatLabel.labelId,b],type:"regular",apiVersion:3,operation:c.SET};else if("addMessageLabel"in a)b={syncAction:{labelAssociationAction:{labeled:!0}},index:[LabelAssociation_1.LabelAssociationType.Message,a.addMessageLabel.labelId,b,a.addMessageLabel.messageId,"0","0"],type:"regular",apiVersion:3,operation:c.SET};else if("removeMessageLabel"in a)b={syncAction:{labelAssociationAction:{labeled:!1}},index:[LabelAssociation_1.LabelAssociationType.Message,a.removeMessageLabel.labelId,b,a.removeMessageLabel.messageId,
"0","0"],type:"regular",apiVersion:3,operation:c.SET};else throw new boom_1.Boom("not supported");b.syncAction.timestamp=Date.now();return b};exports.chatModificationToAppPatch=chatModificationToAppPatch;
const processSyncAction=(a,b,c,g,f)=>{function h(v,t){return m?w=>{if(w=w.historySets.chats[v]||w.chatUpserts[v])return t?Number((null===t||void 0===t?void 0:t.lastMessageTimestamp)||(null===t||void 0===t?void 0:t.lastSystemMessageTimestamp)||0)>=Number((null===w||void 0===w?void 0:w.lastMessageRecvTimestamp)||0):!0}:void 0}var e,k,l,p;const m=!!g;var n=null===g||void 0===g?void 0:g.accountSettings;null===f||void 0===f||f.trace({syncAction:a,initialSync:!!g},"processing sync action");const {syncAction:{value:d},
index:[r,q,x,u]}=a;if(null===d||void 0===d?0:d.muteAction)b.emit("chats.update",[{id:q,muteEndTime:(null===(e=d.muteAction)||void 0===e?0:e.muted)?(0,generics_1.toNumber)(d.muteAction.muteEndTimestamp):null,conditional:h(q,void 0)}]);else if((null===d||void 0===d?0:d.archiveChatAction)||"archive"===r||"unarchive"===r)a=null===d||void 0===d?void 0:d.archiveChatAction,b.emit("chats.update",[{id:q,archived:a?a.archived:"archive"===r,conditional:h(q,(null===n||void 0===n?0:n.unarchiveChats)?null===a||
void 0===a?void 0:a.messageRange:void 0)}]);else if(null===d||void 0===d?0:d.markChatAsReadAction)n=d.markChatAsReadAction,b.emit("chats.update",[{id:q,unreadCount:m&&n.read?null:(null===n||void 0===n?0:n.read)?0:-1,conditional:h(q,null===n||void 0===n?void 0:n.messageRange)}]);else if((null===d||void 0===d?0:d.deleteMessageForMeAction)||"deleteMessageForMe"===r)b.emit("messages.delete",{keys:[{remoteJid:q,id:x,fromMe:"1"===u}]});else if(null===d||void 0===d?0:d.contactAction)b.emit("contacts.upsert",
[{id:q,name:d.contactAction.fullName}]);else if(null===d||void 0===d?0:d.pushNameSetting)(n=null===(k=null===d||void 0===d?void 0:d.pushNameSetting)||void 0===k?void 0:k.name)&&(null===c||void 0===c?void 0:c.name)!==n&&b.emit("creds.update",{me:{...c,name:n}});else if(null===d||void 0===d?0:d.pinAction)b.emit("chats.update",[{id:q,pinned:(null===(l=d.pinAction)||void 0===l?0:l.pinned)?(0,generics_1.toNumber)(d.timestamp):null,conditional:h(q,void 0)}]);else if(null===d||void 0===d?0:d.unarchiveChatsSetting)a=
!!d.unarchiveChatsSetting.unarchiveChats,b.emit("creds.update",{accountSettings:{unarchiveChats:a}}),null===f||void 0===f||f.info(`archive setting updated => '${d.unarchiveChatsSetting.unarchiveChats}'`),n&&(n.unarchiveChats=a);else if((null===d||void 0===d?0:d.starAction)||"star"===r)n=null===(p=null===d||void 0===d?void 0:d.starAction)||void 0===p?void 0:p.starred,"boolean"!==typeof n&&(n="1"===a.index[a.index.length-1]),b.emit("messages.update",[{key:{remoteJid:q,id:x,fromMe:"1"===u},update:{starred:n}}]);
else if((null===d||void 0===d?0:d.deleteChatAction)||"deleteChat"===r)m||b.emit("chats.delete",[q]);else if(null===d||void 0===d?0:d.labelEditAction){const {name:v,color:t,deleted:w,predefinedId:y}=d.labelEditAction;b.emit("labels.edit",{id:q,name:v,color:t,deleted:w,predefinedId:y?String(y):void 0})}else(null===d||void 0===d?0:d.labelAssociationAction)?b.emit("labels.association",{type:d.labelAssociationAction.labeled?"add":"remove",association:r===LabelAssociation_1.LabelAssociationType.Chat?{type:LabelAssociation_1.LabelAssociationType.Chat,
chatId:a.index[2],labelId:a.index[1]}:{type:LabelAssociation_1.LabelAssociationType.Message,chatId:a.index[2],messageId:a.index[3],labelId:a.index[1]}}):null===f||void 0===f||f.debug({syncAction:a,id:q},"unprocessable update")};exports.processSyncAction=processSyncAction;
